//! TEI XML writer for rescribe.
//!
//! Serializes rescribe's document IR to TEI (Text Encoding Initiative) XML.

use quick_xml::Writer;
use quick_xml::events::{BytesDecl, BytesEnd, BytesStart, BytesText, Event};
use rescribe_core::{ConversionResult, Document, EmitError, Node};
use rescribe_std::{node, prop};
use std::io::Cursor;

/// Emit a document to TEI XML.
pub fn emit(doc: &Document) -> Result<ConversionResult<Vec<u8>>, EmitError> {
    let warnings = Vec::new();
    let mut writer = Writer::new(Cursor::new(Vec::new()));

    // XML declaration
    writer
        .write_event(Event::Decl(BytesDecl::new("1.0", Some("UTF-8"), None)))
        .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;

    // Start TEI element
    let mut tei = BytesStart::new("TEI");
    tei.push_attribute(("xmlns", "http://www.tei-c.org/ns/1.0"));
    writer
        .write_event(Event::Start(tei))
        .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;

    // Write teiHeader if we have metadata
    let has_title = doc.metadata.get_str("title").is_some();
    if has_title {
        writer
            .write_event(Event::Start(BytesStart::new("teiHeader")))
            .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        writer
            .write_event(Event::Start(BytesStart::new("fileDesc")))
            .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        writer
            .write_event(Event::Start(BytesStart::new("titleStmt")))
            .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;

        if let Some(title) = doc.metadata.get_str("title") {
            write_element(&mut writer, "title", title)?;
        }

        writer
            .write_event(Event::End(BytesEnd::new("titleStmt")))
            .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        writer
            .write_event(Event::Start(BytesStart::new("publicationStmt")))
            .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        write_element(&mut writer, "p", "Generated by rescribe")?;
        writer
            .write_event(Event::End(BytesEnd::new("publicationStmt")))
            .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        writer
            .write_event(Event::Start(BytesStart::new("sourceDesc")))
            .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        write_element(&mut writer, "p", "Converted document")?;
        writer
            .write_event(Event::End(BytesEnd::new("sourceDesc")))
            .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        writer
            .write_event(Event::End(BytesEnd::new("fileDesc")))
            .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        writer
            .write_event(Event::End(BytesEnd::new("teiHeader")))
            .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
    }

    // Write text/body
    writer
        .write_event(Event::Start(BytesStart::new("text")))
        .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
    writer
        .write_event(Event::Start(BytesStart::new("body")))
        .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;

    for child in &doc.content.children {
        write_node(&mut writer, child)?;
    }

    writer
        .write_event(Event::End(BytesEnd::new("body")))
        .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
    writer
        .write_event(Event::End(BytesEnd::new("text")))
        .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;

    // End TEI
    writer
        .write_event(Event::End(BytesEnd::new("TEI")))
        .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;

    let result = writer.into_inner().into_inner();
    Ok(ConversionResult::with_warnings(result, warnings))
}

fn write_element(
    writer: &mut Writer<Cursor<Vec<u8>>>,
    tag: &str,
    text: &str,
) -> Result<(), EmitError> {
    writer
        .write_event(Event::Start(BytesStart::new(tag)))
        .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
    writer
        .write_event(Event::Text(BytesText::new(text)))
        .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
    writer
        .write_event(Event::End(BytesEnd::new(tag)))
        .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
    Ok(())
}

fn write_node(writer: &mut Writer<Cursor<Vec<u8>>>, node: &Node) -> Result<(), EmitError> {
    match node.kind.as_str() {
        node::DOCUMENT | node::DIV => {
            // Wrap divisions in div element
            if node.kind.as_str() == node::DIV {
                writer
                    .write_event(Event::Start(BytesStart::new("div")))
                    .map_err(|e| {
                        EmitError::Io(std::io::Error::other(format!("XML error: {}", e)))
                    })?;
            }
            for child in &node.children {
                write_node(writer, child)?;
            }
            if node.kind.as_str() == node::DIV {
                writer
                    .write_event(Event::End(BytesEnd::new("div")))
                    .map_err(|e| {
                        EmitError::Io(std::io::Error::other(format!("XML error: {}", e)))
                    })?;
            }
        }

        node::HEADING => {
            writer
                .write_event(Event::Start(BytesStart::new("head")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("head")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::PARAGRAPH => {
            writer
                .write_event(Event::Start(BytesStart::new("p")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("p")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::BLOCKQUOTE => {
            writer
                .write_event(Event::Start(BytesStart::new("quote")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_node(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("quote")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::LIST => {
            let ordered = node.props.get_bool(prop::ORDERED).unwrap_or(false);
            let mut list = BytesStart::new("list");
            if ordered {
                list.push_attribute(("rend", "numbered"));
            }

            writer
                .write_event(Event::Start(list))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_node(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("list")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::LIST_ITEM => {
            writer
                .write_event(Event::Start(BytesStart::new("item")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_node(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("item")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::DEFINITION_LIST => {
            writer
                .write_event(Event::Start(BytesStart::new("gloss")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_node(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("gloss")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::DEFINITION_TERM => {
            writer
                .write_event(Event::Start(BytesStart::new("term")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("term")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::DEFINITION_DESC => {
            writer
                .write_event(Event::Start(BytesStart::new("def")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_node(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("def")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::CODE_BLOCK => {
            writer
                .write_event(Event::Start(BytesStart::new("eg")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;

            if let Some(content) = node.props.get_str(prop::CONTENT) {
                writer
                    .write_event(Event::Text(BytesText::new(content)))
                    .map_err(|e| {
                        EmitError::Io(std::io::Error::other(format!("XML error: {}", e)))
                    })?;
            }

            writer
                .write_event(Event::End(BytesEnd::new("eg")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::TABLE => {
            writer
                .write_event(Event::Start(BytesStart::new("table")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;

            for child in &node.children {
                write_node(writer, child)?;
            }

            writer
                .write_event(Event::End(BytesEnd::new("table")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::TABLE_HEAD | node::TABLE_BODY | node::TABLE_FOOT => {
            // TEI doesn't have thead/tbody, pass through
            for child in &node.children {
                write_node(writer, child)?;
            }
        }

        node::TABLE_ROW => {
            writer
                .write_event(Event::Start(BytesStart::new("row")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_node(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("row")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::TABLE_CELL => {
            writer
                .write_event(Event::Start(BytesStart::new("cell")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("cell")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::TABLE_HEADER => {
            let mut cell = BytesStart::new("cell");
            cell.push_attribute(("rend", "header"));
            writer
                .write_event(Event::Start(cell))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("cell")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::FIGURE => {
            writer
                .write_event(Event::Start(BytesStart::new("figure")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_node(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("figure")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::IMAGE => {
            let mut graphic = BytesStart::new("graphic");
            if let Some(url) = node.props.get_str(prop::URL) {
                graphic.push_attribute(("url", url));
            }
            writer
                .write_event(Event::Empty(graphic))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::HORIZONTAL_RULE => {
            // Use page break marker
            writer
                .write_event(Event::Empty(BytesStart::new("pb")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::FOOTNOTE_DEF => {
            writer
                .write_event(Event::Start(BytesStart::new("note")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_node(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("note")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        "math_display" => {
            writer
                .write_event(Event::Start(BytesStart::new("formula")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            if let Some(source) = node.props.get_str("math:source") {
                writer
                    .write_event(Event::Text(BytesText::new(source)))
                    .map_err(|e| {
                        EmitError::Io(std::io::Error::other(format!("XML error: {}", e)))
                    })?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("formula")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        // Inline nodes that appear at block level
        node::TEXT | node::EMPHASIS | node::STRONG | node::CODE | node::LINK => {
            writer
                .write_event(Event::Start(BytesStart::new("p")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            write_inline(writer, node)?;
            writer
                .write_event(Event::End(BytesEnd::new("p")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        _ => {
            for child in &node.children {
                write_node(writer, child)?;
            }
        }
    }

    Ok(())
}

fn write_inline(writer: &mut Writer<Cursor<Vec<u8>>>, node: &Node) -> Result<(), EmitError> {
    match node.kind.as_str() {
        node::TEXT => {
            if let Some(content) = node.props.get_str(prop::CONTENT) {
                writer
                    .write_event(Event::Text(BytesText::new(content)))
                    .map_err(|e| {
                        EmitError::Io(std::io::Error::other(format!("XML error: {}", e)))
                    })?;
            }
        }

        node::EMPHASIS => {
            let mut hi = BytesStart::new("hi");
            hi.push_attribute(("rend", "italic"));
            writer
                .write_event(Event::Start(hi))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("hi")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::STRONG => {
            let mut hi = BytesStart::new("hi");
            hi.push_attribute(("rend", "bold"));
            writer
                .write_event(Event::Start(hi))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("hi")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::UNDERLINE => {
            let mut hi = BytesStart::new("hi");
            hi.push_attribute(("rend", "underline"));
            writer
                .write_event(Event::Start(hi))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("hi")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::STRIKEOUT => {
            let mut hi = BytesStart::new("hi");
            hi.push_attribute(("rend", "strike"));
            writer
                .write_event(Event::Start(hi))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("hi")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::SUBSCRIPT => {
            let mut hi = BytesStart::new("hi");
            hi.push_attribute(("rend", "sub"));
            writer
                .write_event(Event::Start(hi))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("hi")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::SUPERSCRIPT => {
            let mut hi = BytesStart::new("hi");
            hi.push_attribute(("rend", "sup"));
            writer
                .write_event(Event::Start(hi))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("hi")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::SMALL_CAPS => {
            let mut hi = BytesStart::new("hi");
            hi.push_attribute(("rend", "sc"));
            writer
                .write_event(Event::Start(hi))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("hi")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::CODE => {
            writer
                .write_event(Event::Start(BytesStart::new("code")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            if let Some(content) = node.props.get_str(prop::CONTENT) {
                writer
                    .write_event(Event::Text(BytesText::new(content)))
                    .map_err(|e| {
                        EmitError::Io(std::io::Error::other(format!("XML error: {}", e)))
                    })?;
            }
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("code")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::LINK => {
            let mut link = BytesStart::new("ref");
            if let Some(url) = node.props.get_str(prop::URL) {
                link.push_attribute(("target", url));
            }
            writer
                .write_event(Event::Start(link))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            for child in &node.children {
                write_inline(writer, child)?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("ref")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::LINE_BREAK => {
            writer
                .write_event(Event::Empty(BytesStart::new("lb")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::SOFT_BREAK => {
            writer
                .write_event(Event::Text(BytesText::new(" ")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        node::IMAGE => {
            let mut graphic = BytesStart::new("graphic");
            if let Some(url) = node.props.get_str(prop::URL) {
                graphic.push_attribute(("url", url));
            }
            writer
                .write_event(Event::Empty(graphic))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        "math_inline" => {
            writer
                .write_event(Event::Start(BytesStart::new("formula")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
            if let Some(source) = node.props.get_str("math:source") {
                writer
                    .write_event(Event::Text(BytesText::new(source)))
                    .map_err(|e| {
                        EmitError::Io(std::io::Error::other(format!("XML error: {}", e)))
                    })?;
            }
            writer
                .write_event(Event::End(BytesEnd::new("formula")))
                .map_err(|e| EmitError::Io(std::io::Error::other(format!("XML error: {}", e))))?;
        }

        _ => {
            for child in &node.children {
                write_inline(writer, child)?;
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use rescribe_core::Properties;

    #[test]
    fn test_emit_empty() {
        let doc = Document {
            content: Node::new(node::DOCUMENT),
            resources: Default::default(),
            metadata: Properties::new(),
            source: None,
        };

        let result = emit(&doc).unwrap();
        let xml = String::from_utf8(result.value).unwrap();
        assert!(xml.contains("<TEI"));
        assert!(xml.contains("</TEI>"));
    }

    #[test]
    fn test_emit_paragraph() {
        let doc = Document {
            content: Node::new(node::DOCUMENT).child(
                Node::new(node::PARAGRAPH)
                    .child(Node::new(node::TEXT).prop(prop::CONTENT, "Hello, world!")),
            ),
            resources: Default::default(),
            metadata: Properties::new(),
            source: None,
        };

        let result = emit(&doc).unwrap();
        let xml = String::from_utf8(result.value).unwrap();
        assert!(xml.contains("<p>Hello, world!</p>"));
    }

    #[test]
    fn test_emit_with_title() {
        let mut metadata = Properties::new();
        metadata.set("title", "Test Document".to_string());

        let doc = Document {
            content: Node::new(node::DOCUMENT),
            resources: Default::default(),
            metadata,
            source: None,
        };

        let result = emit(&doc).unwrap();
        let xml = String::from_utf8(result.value).unwrap();
        assert!(xml.contains("<title>Test Document</title>"));
    }

    #[test]
    fn test_emit_formatting() {
        let doc = Document {
            content: Node::new(node::DOCUMENT).child(
                Node::new(node::PARAGRAPH)
                    .child(
                        Node::new(node::EMPHASIS)
                            .child(Node::new(node::TEXT).prop(prop::CONTENT, "italic")),
                    )
                    .child(Node::new(node::TEXT).prop(prop::CONTENT, " and "))
                    .child(
                        Node::new(node::STRONG)
                            .child(Node::new(node::TEXT).prop(prop::CONTENT, "bold")),
                    ),
            ),
            resources: Default::default(),
            metadata: Properties::new(),
            source: None,
        };

        let result = emit(&doc).unwrap();
        let xml = String::from_utf8(result.value).unwrap();
        assert!(xml.contains("<hi rend=\"italic\">italic</hi>"));
        assert!(xml.contains("<hi rend=\"bold\">bold</hi>"));
    }
}
